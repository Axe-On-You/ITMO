ORG 0x40D
TCOUNT: 	WORD 0x0002 	; Константа: количество тестов.
RESULT: 	WORD 0x0001 	; Результат работы тест-программы.
TEMP_TC: 	WORD ? 		; Вспомогательная ячейка для счётчика.
START: 	LD TCOUNT
		ST TEMP_TC 		; Инициализируем счётчик.
		LD #1
		ST RESULT 		; Инициализируем результат.
		CALL $TEST1 	; Вызываем первый тест.
		CALL $TEST2 	; Вызываем второй тест.
LOOP_ADDR: 	POP 			; Нужно взять со стека число…
		AND RESULT 		; И логически умножить на результат.
		ST RESULT 		; Не забываем все сохранить.
		LOOP TEMP_TC 	; Остались результаты тестов?
		JUMP LOOP_ADDR 	; Да – учтем и их. Нет – на выход!
		HLT 			; Тот самый выход!
	
ORG 0x420
TEST1: 	LD TEST1_AC 	; Загружаем тестовое значение AC.
		WORD 0x942C 	; Вызываем синтезированную команду.
 		LD TEST1_M 		; Загружаем ее результат работы.
		CMP TEST1_CV 	; Сравниваем с эталонным.
 		BEQ T1_PASS 	; Равен эталону?
T1_FAIL: 	CLA 			; Нет – загрузим 0 в AC.
 		JUMP T1_RETURN 	; И отправимся на возврат.
T1_PASS: 	LD #1 		; Да – загрузим 1 в AC.
T1_RETURN: 	SWAP 			; Не забываем про адрес возврата.
		PUSH 			; Вернем результат теста.
 		RET 			; Возврат управления.
TEST1_AC: 	WORD 0xFF01 	; Тестовое значение AC.
TEST1_M: 	WORD 0x5233 	; Тестовая ячейка памяти для MSUB.
TEST1_CV: 	WORD 0x5332 	; Ожидаемый результат.

ORG 0x430
TEST2: 	LD TEST2_AC 	; Загружаем тестовое значение AC.
		WORD 0x943C 	; Вызываем синтезированную команду.
		LD TEST2_M 		; Загружаем ее результат работы.
		CMP TEST2_CV 	; Сравниваем с эталонным.
		BEQ T2_PASS 	; Равен эталону?
T2_FAIL: 	CLA 			; Нет – загрузим 0 в AC.
		JUMP T1_RETURN 	; И отправимся на возврат.
T2_PASS: 	LD #1 		; Да – загрузим 1 в AC.
T2_RETURN: 	SWAP 			; Не забываем про адрес возврата
		PUSH 			; Вернем результат теста.
		RET 			; Возврат управления.
TEST2_AC: 	WORD 0x6001 	; Тестовое значение AC.
TEST2_M: 	WORD 0x7FFF 	; Тестовая ячейка памяти для MSUB.
TEST2_CV: 	WORD 0x1FFE 	; Ожидаемый результат.